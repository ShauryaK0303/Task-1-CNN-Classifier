SOM(COMPETITIVE LEARNING)

import numpy as np

def euclidean_distance_squared(vector1, vector2):
    return np.sum((vector1 - vector2) ** 2)

input_vector1 = np.array([1, 1, 0, 0])
input_vector2 = np.array([0, 0, 0, 1])
input_vector3 = np.array([0, 0, 1, 1])
input_vector4 = np.array([1, 1, 0, 0])
weights_y1 = np.array([0.2, 0.6, 0.5, 0.9])
weights_y2 = np.array([0.8, 0.4, 0.7, 0.3])
learning_rate = 0.6
input = [input_vector1, input_vector2, input_vector3, input_vector4]

def SOM(input_vector, weights_y1, weights_y2):
    distance_y1 = euclidean_distance_squared(input_vector, weights_y1)
    distance_y2 = euclidean_distance_squared(input_vector, weights_y2)
    winning_neuron = 1 if distance_y1 < distance_y2 else 2
    print("Winning Neuron is : ", winning_neuron)
    if winning_neuron == 1:
        weights_y1 = weights_y1 + learning_rate * (input_vector - weights_y1)
    else:
        weights_y2 = weights_y2 + learning_rate * (input_vector - weights_y2)
    return weights_y1, weights_y2

for i in range(4):
    print("Input : ", input[i])
    weights_y1, weights_y2 = SOM(input[i], weights_y1, weights_y2)
    print("Updated weights for y1:", weights_y1)
    print("Updated weights for y2:", weights_y2)
    print("")

